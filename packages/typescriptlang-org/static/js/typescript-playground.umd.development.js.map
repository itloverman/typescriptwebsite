{"version":3,"file":"typescript-playground.umd.development.js","sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/typeAcquisition.ts","../src/monacoTSVersions.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * Type Defs we've already got, and nulls when something has failed.\n * This is to make sure that it doesn't infinite loop.\n */\nexport const acquiredTypeDefs: { [name: string]: string | null } = {}\n\nexport type AddLibToRuntimeFunc = (code: string, path: string) => void\n\n/**\n * Pseudo in-browser type acquisition\n *\n * @param sourceCode the root source code to look at\n * @param addLibraryToRuntime\n */\n\nexport const detectNewImportsToAcquireTypeFor = async (\n  sourceCode: string,\n  addLibraryToRuntime: AddLibToRuntimeFunc\n) => {\n  const getTypeDependenciesForSourceCode = async (\n    sourceCode: string,\n    mod: string | undefined,\n    path: string | undefined\n  ) => {\n    // TODO: debounce\n    //\n    // TODO: This needs to be replaced by the AST - it still works in comments\n    // blocked by https://github.com/microsoft/monaco-typescript/pull/38\n    //\n    // https://regex101.com/r/Jxa3KX/4\n    const requirePattern = /(const|let|var)(.|\\n)*? require\\(('|\")(.*)('|\")\\);?$/\n    //  https://regex101.com/r/hdEpzO/4\n    const es6Pattern = /(import|export)((?!from)(?!require)(.|\\n))*?(from|require\\()\\s?('|\")(.*)('|\")\\)?;?$/gm\n\n    const foundModules = new Set<string>()\n    var match\n\n    while ((match = es6Pattern.exec(sourceCode)) !== null) {\n      if (match[6]) foundModules.add(match[6])\n    }\n\n    while ((match = requirePattern.exec(sourceCode)) !== null) {\n      if (match[5]) foundModules.add(match[5])\n    }\n\n    const moduleJSONURL = (name: string) =>\n      `https://ofcncog2cu-dsn.algolia.net/1/indexes/npm-search/${name}?attributes=types&x-algolia-agent=Algolia%20for%20vanilla%20JavaScript%20(lite)%203.27.1&x-algolia-application-id=OFCNCOG2CU&x-algolia-api-key=f54e21fa3a2a0160595bb058179bfb1e`\n    const unpkgURL = (name: string, path: string) =>\n      `https://www.unpkg.com/${encodeURIComponent(name)}/${encodeURIComponent(path)}`\n    const packageJSONURL = (name: string) => unpkgURL(name, 'package.json')\n    const errorMsg = (msg: string, response: any) => {\n      console.error(`${msg} - will not try again in this session`, response.status, response.statusText, response)\n      debugger\n    }\n\n    //  const addLibraryToRuntime = (code:string, path:string) => {\n    //    const defaults = monacoLanguageDefaults({ isJS: path.endsWith(\"js\") })\n    //    defaults.addExtraLib(code, path);\n    //    console.log(`Adding ${path} to runtime`)\n    //  }\n\n    const getReferenceDependencies = async (sourceCode: string, mod: string, path: string) => {\n      if (sourceCode.indexOf('reference path') > 0) {\n        // https://regex101.com/r/DaOegw/1\n        const referencePathExtractionPattern = /<reference path=\"(.*)\" \\/>/gm\n        while ((match = referencePathExtractionPattern.exec(sourceCode)) !== null) {\n          const relativePath = match[1]\n          if (relativePath) {\n            let newPath = mapRelativePath(mod, relativePath, path)\n            if (newPath) {\n              const dtsRefURL = unpkgURL(mod, newPath)\n              const dtsReferenceResponse = await fetch(dtsRefURL)\n              if (!dtsReferenceResponse.ok) {\n                return errorMsg(\n                  `Could not get ${newPath} for a reference link in the module '${mod}' from ${path}`,\n                  dtsReferenceResponse\n                )\n              }\n\n              let dtsReferenceResponseText = await dtsReferenceResponse.text()\n              if (!dtsReferenceResponseText) {\n                return errorMsg(\n                  `Could not get ${newPath} for a reference link for the module '${mod}' from ${path}`,\n                  dtsReferenceResponse\n                )\n              }\n\n              await getTypeDependenciesForSourceCode(dtsReferenceResponseText, mod, newPath)\n              const representationalPath = `node_modules/${mod}/${newPath}`\n              addLibraryToRuntime(dtsReferenceResponseText, representationalPath)\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Takes an initial module and the path for the root of the typings and grab it and start grabbing its\n     * dependencies then add those the to runtime.\n     *\n     * @param {string} mod The module name\n     * @param {string} path  The path to the root def type\n     */\n    const addModuleToRuntime = async (mod: string, path: string) => {\n      const isDeno = path && path.indexOf('https://') === 0\n\n      const dtsFileURL = isDeno ? path : unpkgURL(mod, path)\n      const dtsResponse = await fetch(dtsFileURL)\n      if (!dtsResponse.ok) {\n        return errorMsg(`Could not get root d.ts file for the module '${mod}' at ${path}`, dtsResponse)\n      }\n\n      // TODO: handle checking for a resolve to index.d.ts whens someone imports the folder\n      let content = await dtsResponse.text()\n      if (!content) {\n        return errorMsg(`Could not get root d.ts file for the module '${mod}' at ${path}`, dtsResponse)\n      }\n\n      // Now look and grab dependent modules where you need the\n      //\n      await getTypeDependenciesForSourceCode(content, mod, path)\n\n      if (isDeno) {\n        const wrapped = `declare module \"${path}\" { ${content} }`\n        addLibraryToRuntime(wrapped, path)\n      } else {\n        const typelessModule = mod.split('@types/').slice(-1)\n        const wrapped = `declare module \"${typelessModule}\" { ${content} }`\n        addLibraryToRuntime(wrapped, `node_modules/${mod}/${path}`)\n      }\n    }\n\n    /**\n     * Takes a module import, then uses both the algolia API and the the package.json to derive\n     * the root type def path.\n     *\n     * @param {string} packageName\n     * @returns {Promise<{ mod: string, path: string, packageJSON: any }>}\n     */\n    const getModuleAndRootDefTypePath = async (packageName: string) => {\n      // For modules\n      const url = moduleJSONURL(packageName)\n\n      const response = await fetch(url)\n      if (!response.ok) {\n        return errorMsg(`Could not get Algolia JSON for the module '${packageName}'`, response)\n      }\n\n      const responseJSON = await response.json()\n      if (!responseJSON) {\n        return errorMsg(`Could not get Algolia JSON for the module '${packageName}'`, response)\n      }\n\n      if (!responseJSON.types) {\n        return console.log(`There were no types for '${packageName}' - will not try again in this session`)\n      }\n      if (!responseJSON.types.ts) {\n        return console.log(`There were no types for '${packageName}' - will not try again in this session`)\n      }\n\n      acquiredTypeDefs[packageName] = responseJSON\n\n      if (responseJSON.types.ts === 'included') {\n        const modPackageURL = packageJSONURL(packageName)\n\n        const response = await fetch(modPackageURL)\n        if (!response.ok) {\n          return errorMsg(`Could not get Package JSON for the module '${packageName}'`, response)\n        }\n\n        const responseJSON = await response.json()\n        if (!responseJSON) {\n          return errorMsg(`Could not get Package JSON for the module '${packageName}'`, response)\n        }\n\n        // Get the path of the root d.ts file\n\n        // non-inferred route\n        let rootTypePath = responseJSON.typing || responseJSON.typings || responseJSON.types\n\n        // package main is custom\n        if (!rootTypePath && typeof responseJSON.main === 'string' && responseJSON.main.indexOf('.js') > 0) {\n          rootTypePath = responseJSON.main.replace(/js$/, 'd.ts')\n        }\n\n        // Final fallback, to have got here it must have passed in algolia\n        if (!rootTypePath) {\n          rootTypePath = 'index.d.ts'\n        }\n\n        return { mod: packageName, path: rootTypePath, packageJSON: responseJSON }\n      } else if (responseJSON.types.ts === 'definitely-typed') {\n        return { mod: responseJSON.types.definitelyTyped, path: 'index.d.ts', packageJSON: responseJSON }\n      } else {\n        throw \"This shouldn't happen\"\n      }\n    }\n\n    const mapModuleNameToModule = (name: string) => {\n      // in node repl:\n      // > require(\"module\").builtinModules\n      const builtInNodeMods = [\n        'assert',\n        'async_hooks',\n        'base',\n        'buffer',\n        'child_process',\n        'cluster',\n        'console',\n        'constants',\n        'crypto',\n        'dgram',\n        'dns',\n        'domain',\n        'events',\n        'fs',\n        'globals',\n        'http',\n        'http2',\n        'https',\n        'index',\n        'inspector',\n        'module',\n        'net',\n        'os',\n        'path',\n        'perf_hooks',\n        'process',\n        'punycode',\n        'querystring',\n        'readline',\n        'repl',\n        'stream',\n        'string_decoder',\n        'timers',\n        'tls',\n        'trace_events',\n        'tty',\n        'url',\n        'util',\n        'v8',\n        'vm',\n        'worker_threads',\n        'zlib',\n      ]\n      if (builtInNodeMods.includes(name)) {\n        return 'node'\n      }\n      return name\n    }\n\n    //** A really dumb version of path.resolve */\n    const mapRelativePath = (_outerModule: string, moduleDeclaration: string, currentPath: string) => {\n      // https://stackoverflow.com/questions/14780350/convert-relative-path-to-absolute-using-javascript\n      function absolute(base: string, relative: string) {\n        if (!base) return relative\n\n        const stack = base.split('/')\n        const parts = relative.split('/')\n        stack.pop() // remove current file name (or empty string)\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] == '.') continue\n          if (parts[i] == '..') stack.pop()\n          else stack.push(parts[i])\n        }\n        return stack.join('/')\n      }\n\n      return absolute(currentPath, moduleDeclaration)\n    }\n\n    const convertToModuleReferenceID = (outerModule: string, moduleDeclaration: string, currentPath: string) => {\n      const modIsScopedPackageOnly = moduleDeclaration.indexOf('@') === 0 && moduleDeclaration.split('/').length === 2\n      const modIsPackageOnly = moduleDeclaration.indexOf('@') === -1 && moduleDeclaration.split('/').length === 1\n      const isPackageRootImport = modIsPackageOnly || modIsScopedPackageOnly\n\n      if (isPackageRootImport) {\n        return moduleDeclaration\n      } else {\n        return `${outerModule}-${mapRelativePath(outerModule, moduleDeclaration, currentPath)}`\n      }\n    }\n\n    /** @type {string[]} */\n    const filteredModulesToLookAt = Array.from(foundModules)\n\n    filteredModulesToLookAt.forEach(async name => {\n      // Support grabbing the hard-coded node modules if needed\n      const moduleToDownload = mapModuleNameToModule(name)\n\n      if (!mod && moduleToDownload.startsWith('.')) {\n        return console.log(\"Can't resolve local relative dependencies\")\n      }\n\n      const moduleID = convertToModuleReferenceID(mod!, moduleToDownload, path!)\n      if (acquiredTypeDefs[moduleID] || acquiredTypeDefs[moduleID] === null) {\n        return\n      }\n\n      const modIsScopedPackageOnly = moduleToDownload.indexOf('@') === 0 && moduleToDownload.split('/').length === 2\n      const modIsPackageOnly = moduleToDownload.indexOf('@') === -1 && moduleToDownload.split('/').length === 1\n      const isPackageRootImport = modIsPackageOnly || modIsScopedPackageOnly\n      const isDenoModule = moduleToDownload.indexOf('https://') === 0\n\n      if (isPackageRootImport) {\n        // So it doesn't run twice for a package\n        acquiredTypeDefs[moduleID] = null\n\n        // E.g. import danger from \"danger\"\n        const packageDef = await getModuleAndRootDefTypePath(moduleToDownload)\n\n        if (packageDef) {\n          acquiredTypeDefs[moduleID] = packageDef.packageJSON\n          await addModuleToRuntime(packageDef.mod, packageDef.path)\n        }\n      } else if (isDenoModule) {\n        // E.g. import { serve } from \"https://deno.land/std@v0.12/http/server.ts\";\n        await addModuleToRuntime(moduleToDownload, moduleToDownload)\n      } else {\n        // E.g. import {Component} from \"./MyThing\"\n        if (!moduleToDownload || !path) throw `No outer module or path for a relative import: ${moduleToDownload}`\n\n        const absolutePathForModule = mapRelativePath(mod!, moduleToDownload, path)\n        // So it doesn't run twice for a package\n        acquiredTypeDefs[moduleID] = null\n        const resolvedFilepath = absolutePathForModule.endsWith('.ts')\n          ? absolutePathForModule\n          : absolutePathForModule + '.d.ts'\n        await addModuleToRuntime(mod!, resolvedFilepath)\n      }\n    })\n    getReferenceDependencies(sourceCode, mod!, path!)\n  }\n\n  // Start diving into the root\n  getTypeDependenciesForSourceCode(sourceCode, undefined, undefined)\n}\n","/**\n * The versions of monaco-typescript which we can use\n * for backwards compatibility with older versions\n * of TS in the playground.\n */\nexport const monacoTSVersions = {\n  '3.5.1': { monaco: '0.17.1' },\n  '3.3.3': { monaco: '0.16.1' },\n  '3.1.6': { monaco: '0.15.6' },\n  '3.0.1': { monaco: '0.14.3' },\n  '2.8.1': { monaco: '0.13.1' },\n  '2.7.2': { monaco: '0.11.1' },\n  '2.4.1': { monaco: '0.10.0' },\n} as const;\n\nexport type SupportedTSVersions = keyof typeof monacoTSVersions\n","import ts from 'typescript'\nimport { SupportedTSVersions } from './monacoTSVersions'\n\n/**\n * These are settings for the playground which are the equivalent to props in React\n * any changes to it should require a new setup of the playground\n */\ntype PlaygroundConfig = {\n  /** The default source code for the playground */\n  text: string\n  /** Should it run the ts or js IDE services */\n  useJavaScript: boolean\n  /** The version of TS we should use */\n  typeScriptVersion: 'bundled' | SupportedTSVersions | 'nightly'\n  /** Compiler options which are automatically just forwarded on */\n  compilerOptions: ts.CompilerOptions\n  /** Optional monaco settings overrides */\n  monacoSettings?: any // TODO: types\n} & (\n  | { /** theID of a dom node to add monaco to */ domID: string }\n  | { /** theID of a dom node to add monaco to */ elementToAppend: Element }\n)\n\nconst languageType = (config: PlaygroundConfig) => (config.useJavaScript ? 'javascript' : 'typescript')\n// const monacoLanguageDefaults = (config: PlaygroundConfig) => config.useJavaScript ? monaco.languages.typescript.javascriptDefaults : monaco.languages.typescript.typescriptDefaults\n// const monacoLanguageWorker = (config: PlaygroundConfig) => config.useJavaScript ? monaco.languages.typescript.getJavaScriptWorker : monaco.languages.typescript.getTypeScriptWorker\n\n/** Default Monaco settings for the sandbox */\nconst sharedEditorOptions = {\n  minimap: { enabled: false },\n  automaticLayout: true,\n  scrollBeyondLastLine: true,\n  scrollBeyondLastColumn: 3,\n}\n\nexport function getDefaultCompilerOptions(config: PlaygroundConfig): ts.CompilerOptions {\n  return {\n    noImplicitAny: true,\n    strictNullChecks: true,\n    strictFunctionTypes: true,\n    strictPropertyInitialization: true,\n    noImplicitThis: true,\n    noImplicitReturns: true,\n\n    alwaysStrict: true,\n    allowUnreachableCode: false,\n    allowUnusedLabels: false,\n\n    downlevelIteration: false,\n    noEmitHelpers: false,\n    noLib: false,\n    noStrictGenericChecks: false,\n    noUnusedLocals: false,\n    noUnusedParameters: false,\n\n    esModuleInterop: false,\n    preserveConstEnums: false,\n    removeComments: false,\n    skipLibCheck: false,\n\n    checkJs: config.useJavaScript,\n    allowJs: config.useJavaScript,\n\n    experimentalDecorators: false,\n    emitDecoratorMetadata: false,\n\n    target: ts.ScriptTarget.ES2017,\n    jsx: monaco.languages.typescript.JsxEmit.None,\n  }\n}\n\nexport function defaultPlaygroundSettings(text: string, domID: string) {\n  const config: PlaygroundConfig = {\n    text,\n    domID,\n    compilerOptions: {},\n    typeScriptVersion: 'bundled',\n    useJavaScript: false,\n  }\n  return config\n}\n\n/** Creates a monaco file reference, basically a fancy path */\nfunction createFileUri(\n  config: PlaygroundConfig,\n  compilerOptions: ts.CompilerOptions,\n  monaco: typeof import('monaco-editor')\n) {\n  const isJSX = compilerOptions.jsx !== monaco.languages.typescript.JsxEmit.None\n  const fileExt = config.useJavaScript ? 'js' : 'ts'\n  const ext = isJSX ? fileExt + 'x' : fileExt\n  const filepath = 'input.' + ext\n  return monaco.Uri.file(filepath)\n}\n\nexport async function setupPlayground(config: PlaygroundConfig, monaco: typeof import('monaco-editor')) {\n  // const defaults = monacoLanguageDefaults(config)\n\n  const language = languageType(config)\n  const filePath = createFileUri(config, config.compilerOptions, monaco)\n  const element = 'domID' in config ? document.getElementById(config.domID) : config.elementToAppend\n  const model = monaco.editor.createModel(config.text, language, filePath)\n\n  const monacoSettings = Object.assign({ model }, sharedEditorOptions, config.monacoSettings || {})\n  const editor = monaco.editor.create(element as any, monacoSettings)\n\n  return editor\n}\n\nexport { detectNewImportsToAcquireTypeFor } from './typeAcquisition'\nexport { monacoTSVersions } from './monacoTSVersions'\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_for","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","acquiredTypeDefs","detectNewImportsToAcquireTypeFor","sourceCode","addLibraryToRuntime","getTypeDependenciesForSourceCode","mod","path","requirePattern","es6Pattern","foundModules","Set","match","exec","add","moduleJSONURL","name","unpkgURL","encodeURIComponent","packageJSONURL","errorMsg","msg","response","console","error","status","statusText","getReferenceDependencies","indexOf","referencePathExtractionPattern","relativePath","newPath","mapRelativePath","dtsRefURL","fetch","dtsReferenceResponse","ok","text","dtsReferenceResponseText","representationalPath","addModuleToRuntime","isDeno","dtsFileURL","dtsResponse","content","wrapped","typelessModule","split","slice","getModuleAndRootDefTypePath","packageName","url","json","responseJSON","types","log","ts","modPackageURL","rootTypePath","typing","typings","main","replace","packageJSON","definitelyTyped","mapModuleNameToModule","builtInNodeMods","includes","_outerModule","moduleDeclaration","currentPath","absolute","base","relative","stack","parts","pop","i","length","push","join","convertToModuleReferenceID","outerModule","modIsScopedPackageOnly","modIsPackageOnly","isPackageRootImport","filteredModulesToLookAt","Array","from","forEach","moduleToDownload","startsWith","moduleID","isDenoModule","packageDef","absolutePathForModule","resolvedFilepath","endsWith","undefined","monacoTSVersions","monaco","setupPlayground","config","language","languageType","filePath","createFileUri","compilerOptions","element","document","getElementById","domID","elementToAppend","model","editor","createModel","monacoSettings","Object","assign","sharedEditorOptions","create","useJavaScript","minimap","enabled","automaticLayout","scrollBeyondLastLine","scrollBeyondLastColumn","getDefaultCompilerOptions","noImplicitAny","strictNullChecks","strictFunctionTypes","strictPropertyInitialization","noImplicitThis","noImplicitReturns","alwaysStrict","allowUnreachableCode","allowUnusedLabels","downlevelIteration","noEmitHelpers","noLib","noStrictGenericChecks","noUnusedLocals","noUnusedParameters","esModuleInterop","preserveConstEnums","removeComments","skipLibCheck","checkJs","allowJs","experimentalDecorators","emitDecoratorMetadata","target","ScriptTarget","ES2017","jsx","languages","typescript","JsxEmit","None","defaultPlaygroundSettings","typeScriptVersion","isJSX","fileExt","ext","filepath","Uri","file"],"mappings":"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"}