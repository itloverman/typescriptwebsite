{"version":3,"file":"typescript-playground.umd.production.min.js","sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/typeAcquisition.ts","../src/index.ts","../src/monacoTSVersions.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/**\n * Type Defs we've already got, and nulls when something has failed.\n * This is to make sure that it doesn't infinite loop.\n */\nexport const acquiredTypeDefs: { [name: string]: string | null } = {}\n\nexport type AddLibToRuntimeFunc = (code: string, path: string) => void\n\n/**\n * Pseudo in-browser type acquisition\n *\n * @param sourceCode the root source code to look at\n * @param addLibraryToRuntime\n */\n\nexport const detectNewImportsToAcquireTypeFor = async (\n  sourceCode: string,\n  addLibraryToRuntime: AddLibToRuntimeFunc\n) => {\n  const getTypeDependenciesForSourceCode = async (\n    sourceCode: string,\n    mod: string | undefined,\n    path: string | undefined\n  ) => {\n    // TODO: debounce\n    //\n    // TODO: This needs to be replaced by the AST - it still works in comments\n    // blocked by https://github.com/microsoft/monaco-typescript/pull/38\n    //\n    // https://regex101.com/r/Jxa3KX/4\n    const requirePattern = /(const|let|var)(.|\\n)*? require\\(('|\")(.*)('|\")\\);?$/\n    //  https://regex101.com/r/hdEpzO/4\n    const es6Pattern = /(import|export)((?!from)(?!require)(.|\\n))*?(from|require\\()\\s?('|\")(.*)('|\")\\)?;?$/gm\n\n    const foundModules = new Set<string>()\n    var match\n\n    while ((match = es6Pattern.exec(sourceCode)) !== null) {\n      if (match[6]) foundModules.add(match[6])\n    }\n\n    while ((match = requirePattern.exec(sourceCode)) !== null) {\n      if (match[5]) foundModules.add(match[5])\n    }\n\n    const moduleJSONURL = (name: string) =>\n      `https://ofcncog2cu-dsn.algolia.net/1/indexes/npm-search/${name}?attributes=types&x-algolia-agent=Algolia%20for%20vanilla%20JavaScript%20(lite)%203.27.1&x-algolia-application-id=OFCNCOG2CU&x-algolia-api-key=f54e21fa3a2a0160595bb058179bfb1e`\n    const unpkgURL = (name: string, path: string) =>\n      `https://www.unpkg.com/${encodeURIComponent(name)}/${encodeURIComponent(path)}`\n    const packageJSONURL = (name: string) => unpkgURL(name, 'package.json')\n    const errorMsg = (msg: string, response: any) => {\n      console.error(`${msg} - will not try again in this session`, response.status, response.statusText, response)\n      debugger\n    }\n\n    //  const addLibraryToRuntime = (code:string, path:string) => {\n    //    const defaults = monacoLanguageDefaults({ isJS: path.endsWith(\"js\") })\n    //    defaults.addExtraLib(code, path);\n    //    console.log(`Adding ${path} to runtime`)\n    //  }\n\n    const getReferenceDependencies = async (sourceCode: string, mod: string, path: string) => {\n      if (sourceCode.indexOf('reference path') > 0) {\n        // https://regex101.com/r/DaOegw/1\n        const referencePathExtractionPattern = /<reference path=\"(.*)\" \\/>/gm\n        while ((match = referencePathExtractionPattern.exec(sourceCode)) !== null) {\n          const relativePath = match[1]\n          if (relativePath) {\n            let newPath = mapRelativePath(mod, relativePath, path)\n            if (newPath) {\n              const dtsRefURL = unpkgURL(mod, newPath)\n              const dtsReferenceResponse = await fetch(dtsRefURL)\n              if (!dtsReferenceResponse.ok) {\n                return errorMsg(\n                  `Could not get ${newPath} for a reference link in the module '${mod}' from ${path}`,\n                  dtsReferenceResponse\n                )\n              }\n\n              let dtsReferenceResponseText = await dtsReferenceResponse.text()\n              if (!dtsReferenceResponseText) {\n                return errorMsg(\n                  `Could not get ${newPath} for a reference link for the module '${mod}' from ${path}`,\n                  dtsReferenceResponse\n                )\n              }\n\n              await getTypeDependenciesForSourceCode(dtsReferenceResponseText, mod, newPath)\n              const representationalPath = `node_modules/${mod}/${newPath}`\n              addLibraryToRuntime(dtsReferenceResponseText, representationalPath)\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Takes an initial module and the path for the root of the typings and grab it and start grabbing its\n     * dependencies then add those the to runtime.\n     *\n     * @param {string} mod The module name\n     * @param {string} path  The path to the root def type\n     */\n    const addModuleToRuntime = async (mod: string, path: string) => {\n      const isDeno = path && path.indexOf('https://') === 0\n\n      const dtsFileURL = isDeno ? path : unpkgURL(mod, path)\n      const dtsResponse = await fetch(dtsFileURL)\n      if (!dtsResponse.ok) {\n        return errorMsg(`Could not get root d.ts file for the module '${mod}' at ${path}`, dtsResponse)\n      }\n\n      // TODO: handle checking for a resolve to index.d.ts whens someone imports the folder\n      let content = await dtsResponse.text()\n      if (!content) {\n        return errorMsg(`Could not get root d.ts file for the module '${mod}' at ${path}`, dtsResponse)\n      }\n\n      // Now look and grab dependent modules where you need the\n      //\n      await getTypeDependenciesForSourceCode(content, mod, path)\n\n      if (isDeno) {\n        const wrapped = `declare module \"${path}\" { ${content} }`\n        addLibraryToRuntime(wrapped, path)\n      } else {\n        const typelessModule = mod.split('@types/').slice(-1)\n        const wrapped = `declare module \"${typelessModule}\" { ${content} }`\n        addLibraryToRuntime(wrapped, `node_modules/${mod}/${path}`)\n      }\n    }\n\n    /**\n     * Takes a module import, then uses both the algolia API and the the package.json to derive\n     * the root type def path.\n     *\n     * @param {string} packageName\n     * @returns {Promise<{ mod: string, path: string, packageJSON: any }>}\n     */\n    const getModuleAndRootDefTypePath = async (packageName: string) => {\n      // For modules\n      const url = moduleJSONURL(packageName)\n\n      const response = await fetch(url)\n      if (!response.ok) {\n        return errorMsg(`Could not get Algolia JSON for the module '${packageName}'`, response)\n      }\n\n      const responseJSON = await response.json()\n      if (!responseJSON) {\n        return errorMsg(`Could not get Algolia JSON for the module '${packageName}'`, response)\n      }\n\n      if (!responseJSON.types) {\n        return console.log(`There were no types for '${packageName}' - will not try again in this session`)\n      }\n      if (!responseJSON.types.ts) {\n        return console.log(`There were no types for '${packageName}' - will not try again in this session`)\n      }\n\n      acquiredTypeDefs[packageName] = responseJSON\n\n      if (responseJSON.types.ts === 'included') {\n        const modPackageURL = packageJSONURL(packageName)\n\n        const response = await fetch(modPackageURL)\n        if (!response.ok) {\n          return errorMsg(`Could not get Package JSON for the module '${packageName}'`, response)\n        }\n\n        const responseJSON = await response.json()\n        if (!responseJSON) {\n          return errorMsg(`Could not get Package JSON for the module '${packageName}'`, response)\n        }\n\n        // Get the path of the root d.ts file\n\n        // non-inferred route\n        let rootTypePath = responseJSON.typing || responseJSON.typings || responseJSON.types\n\n        // package main is custom\n        if (!rootTypePath && typeof responseJSON.main === 'string' && responseJSON.main.indexOf('.js') > 0) {\n          rootTypePath = responseJSON.main.replace(/js$/, 'd.ts')\n        }\n\n        // Final fallback, to have got here it must have passed in algolia\n        if (!rootTypePath) {\n          rootTypePath = 'index.d.ts'\n        }\n\n        return { mod: packageName, path: rootTypePath, packageJSON: responseJSON }\n      } else if (responseJSON.types.ts === 'definitely-typed') {\n        return { mod: responseJSON.types.definitelyTyped, path: 'index.d.ts', packageJSON: responseJSON }\n      } else {\n        throw \"This shouldn't happen\"\n      }\n    }\n\n    const mapModuleNameToModule = (name: string) => {\n      // in node repl:\n      // > require(\"module\").builtinModules\n      const builtInNodeMods = [\n        'assert',\n        'async_hooks',\n        'base',\n        'buffer',\n        'child_process',\n        'cluster',\n        'console',\n        'constants',\n        'crypto',\n        'dgram',\n        'dns',\n        'domain',\n        'events',\n        'fs',\n        'globals',\n        'http',\n        'http2',\n        'https',\n        'index',\n        'inspector',\n        'module',\n        'net',\n        'os',\n        'path',\n        'perf_hooks',\n        'process',\n        'punycode',\n        'querystring',\n        'readline',\n        'repl',\n        'stream',\n        'string_decoder',\n        'timers',\n        'tls',\n        'trace_events',\n        'tty',\n        'url',\n        'util',\n        'v8',\n        'vm',\n        'worker_threads',\n        'zlib',\n      ]\n      if (builtInNodeMods.includes(name)) {\n        return 'node'\n      }\n      return name\n    }\n\n    //** A really dumb version of path.resolve */\n    const mapRelativePath = (_outerModule: string, moduleDeclaration: string, currentPath: string) => {\n      // https://stackoverflow.com/questions/14780350/convert-relative-path-to-absolute-using-javascript\n      function absolute(base: string, relative: string) {\n        if (!base) return relative\n\n        const stack = base.split('/')\n        const parts = relative.split('/')\n        stack.pop() // remove current file name (or empty string)\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] == '.') continue\n          if (parts[i] == '..') stack.pop()\n          else stack.push(parts[i])\n        }\n        return stack.join('/')\n      }\n\n      return absolute(currentPath, moduleDeclaration)\n    }\n\n    const convertToModuleReferenceID = (outerModule: string, moduleDeclaration: string, currentPath: string) => {\n      const modIsScopedPackageOnly = moduleDeclaration.indexOf('@') === 0 && moduleDeclaration.split('/').length === 2\n      const modIsPackageOnly = moduleDeclaration.indexOf('@') === -1 && moduleDeclaration.split('/').length === 1\n      const isPackageRootImport = modIsPackageOnly || modIsScopedPackageOnly\n\n      if (isPackageRootImport) {\n        return moduleDeclaration\n      } else {\n        return `${outerModule}-${mapRelativePath(outerModule, moduleDeclaration, currentPath)}`\n      }\n    }\n\n    /** @type {string[]} */\n    const filteredModulesToLookAt = Array.from(foundModules)\n\n    filteredModulesToLookAt.forEach(async name => {\n      // Support grabbing the hard-coded node modules if needed\n      const moduleToDownload = mapModuleNameToModule(name)\n\n      if (!mod && moduleToDownload.startsWith('.')) {\n        return console.log(\"Can't resolve local relative dependencies\")\n      }\n\n      const moduleID = convertToModuleReferenceID(mod!, moduleToDownload, path!)\n      if (acquiredTypeDefs[moduleID] || acquiredTypeDefs[moduleID] === null) {\n        return\n      }\n\n      const modIsScopedPackageOnly = moduleToDownload.indexOf('@') === 0 && moduleToDownload.split('/').length === 2\n      const modIsPackageOnly = moduleToDownload.indexOf('@') === -1 && moduleToDownload.split('/').length === 1\n      const isPackageRootImport = modIsPackageOnly || modIsScopedPackageOnly\n      const isDenoModule = moduleToDownload.indexOf('https://') === 0\n\n      if (isPackageRootImport) {\n        // So it doesn't run twice for a package\n        acquiredTypeDefs[moduleID] = null\n\n        // E.g. import danger from \"danger\"\n        const packageDef = await getModuleAndRootDefTypePath(moduleToDownload)\n\n        if (packageDef) {\n          acquiredTypeDefs[moduleID] = packageDef.packageJSON\n          await addModuleToRuntime(packageDef.mod, packageDef.path)\n        }\n      } else if (isDenoModule) {\n        // E.g. import { serve } from \"https://deno.land/std@v0.12/http/server.ts\";\n        await addModuleToRuntime(moduleToDownload, moduleToDownload)\n      } else {\n        // E.g. import {Component} from \"./MyThing\"\n        if (!moduleToDownload || !path) throw `No outer module or path for a relative import: ${moduleToDownload}`\n\n        const absolutePathForModule = mapRelativePath(mod!, moduleToDownload, path)\n        // So it doesn't run twice for a package\n        acquiredTypeDefs[moduleID] = null\n        const resolvedFilepath = absolutePathForModule.endsWith('.ts')\n          ? absolutePathForModule\n          : absolutePathForModule + '.d.ts'\n        await addModuleToRuntime(mod!, resolvedFilepath)\n      }\n    })\n    getReferenceDependencies(sourceCode, mod!, path!)\n  }\n\n  // Start diving into the root\n  getTypeDependenciesForSourceCode(sourceCode, undefined, undefined)\n}\n","import ts from 'typescript'\nimport { SupportedTSVersions } from './monacoTSVersions'\n\n/**\n * These are settings for the playground which are the equivalent to props in React\n * any changes to it should require a new setup of the playground\n */\ntype PlaygroundConfig = {\n  /** The default source code for the playground */\n  text: string\n  /** Should it run the ts or js IDE services */\n  useJavaScript: boolean\n  /** The version of TS we should use */\n  typeScriptVersion: 'bundled' | SupportedTSVersions | 'nightly'\n  /** Compiler options which are automatically just forwarded on */\n  compilerOptions: ts.CompilerOptions\n  /** Optional monaco settings overrides */\n  monacoSettings?: any // TODO: types\n} & (\n  | { /** theID of a dom node to add monaco to */ domID: string }\n  | { /** theID of a dom node to add monaco to */ elementToAppend: Element }\n)\n\nconst languageType = (config: PlaygroundConfig) => (config.useJavaScript ? 'javascript' : 'typescript')\n// const monacoLanguageDefaults = (config: PlaygroundConfig) => config.useJavaScript ? monaco.languages.typescript.javascriptDefaults : monaco.languages.typescript.typescriptDefaults\n// const monacoLanguageWorker = (config: PlaygroundConfig) => config.useJavaScript ? monaco.languages.typescript.getJavaScriptWorker : monaco.languages.typescript.getTypeScriptWorker\n\n/** Default Monaco settings for the sandbox */\nconst sharedEditorOptions = {\n  minimap: { enabled: false },\n  automaticLayout: true,\n  scrollBeyondLastLine: true,\n  scrollBeyondLastColumn: 3,\n}\n\nexport function getDefaultCompilerOptions(config: PlaygroundConfig): ts.CompilerOptions {\n  return {\n    noImplicitAny: true,\n    strictNullChecks: true,\n    strictFunctionTypes: true,\n    strictPropertyInitialization: true,\n    noImplicitThis: true,\n    noImplicitReturns: true,\n\n    alwaysStrict: true,\n    allowUnreachableCode: false,\n    allowUnusedLabels: false,\n\n    downlevelIteration: false,\n    noEmitHelpers: false,\n    noLib: false,\n    noStrictGenericChecks: false,\n    noUnusedLocals: false,\n    noUnusedParameters: false,\n\n    esModuleInterop: false,\n    preserveConstEnums: false,\n    removeComments: false,\n    skipLibCheck: false,\n\n    checkJs: config.useJavaScript,\n    allowJs: config.useJavaScript,\n\n    experimentalDecorators: false,\n    emitDecoratorMetadata: false,\n\n    target: ts.ScriptTarget.ES2017,\n    jsx: monaco.languages.typescript.JsxEmit.None,\n  }\n}\n\nexport function defaultPlaygroundSettings(text: string, domID: string) {\n  const config: PlaygroundConfig = {\n    text,\n    domID,\n    compilerOptions: {},\n    typeScriptVersion: 'bundled',\n    useJavaScript: false,\n  }\n  return config\n}\n\n/** Creates a monaco file reference, basically a fancy path */\nfunction createFileUri(\n  config: PlaygroundConfig,\n  compilerOptions: ts.CompilerOptions,\n  monaco: typeof import('monaco-editor')\n) {\n  const isJSX = compilerOptions.jsx !== monaco.languages.typescript.JsxEmit.None\n  const fileExt = config.useJavaScript ? 'js' : 'ts'\n  const ext = isJSX ? fileExt + 'x' : fileExt\n  const filepath = 'input.' + ext\n  return monaco.Uri.file(filepath)\n}\n\nexport async function setupPlayground(config: PlaygroundConfig, monaco: typeof import('monaco-editor')) {\n  // const defaults = monacoLanguageDefaults(config)\n\n  const language = languageType(config)\n  const filePath = createFileUri(config, config.compilerOptions, monaco)\n  const element = 'domID' in config ? document.getElementById(config.domID) : config.elementToAppend\n  const model = monaco.editor.createModel(config.text, language, filePath)\n\n  const monacoSettings = Object.assign({ model }, sharedEditorOptions, config.monacoSettings || {})\n  const editor = monaco.editor.create(element as any, monacoSettings)\n\n  return editor\n}\n\nexport { detectNewImportsToAcquireTypeFor } from './typeAcquisition'\nexport { monacoTSVersions } from './monacoTSVersions'\n","/**\n * The versions of monaco-typescript which we can use\n * for backwards compatibility with older versions\n * of TS in the playground.\n */\nexport const monacoTSVersions = {\n  '3.5.1': { monaco: '0.17.1' },\n  '3.3.3': { monaco: '0.16.1' },\n  '3.1.6': { monaco: '0.15.6' },\n  '3.0.1': { monaco: '0.14.3' },\n  '2.8.1': { monaco: '0.13.1' },\n  '2.7.2': { monaco: '0.11.1' },\n  '2.4.1': { monaco: '0.10.0' },\n} as const;\n\nexport type SupportedTSVersions = keyof typeof monacoTSVersions\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","Symbol","iterator","asyncIterator","acquiredTypeDefs","sharedEditorOptions","minimap","enabled","automaticLayout","scrollBeyondLastLine","scrollBeyondLastColumn","text","domID","compilerOptions","typeScriptVersion","useJavaScript","sourceCode","addLibraryToRuntime","getTypeDependenciesForSourceCode","mod","path","match","requirePattern","es6Pattern","foundModules","Set","exec","add","unpkgURL","name","encodeURIComponent","errorMsg","msg","response","console","error","status","statusText","addModuleToRuntime","isDeno","indexOf","dtsFileURL","fetch","dtsResponse","ok","content","typelessModule","split","slice","mapRelativePath","_outerModule","moduleDeclaration","currentPath","base","relative","stack","parts","pop","i","length","push","join","absolute","Array","from","forEach","moduleToDownload","includes","mapModuleNameToModule","startsWith","log","moduleID","outerModule","modIsScopedPackageOnly","convertToModuleReferenceID","isPackageRootImport","isDenoModule","packageName","json","responseJSON","types","ts","modPackageURL","packageJSONURL","rootTypePath","typing","typings","main","replace","packageJSON","definitelyTyped","getModuleAndRootDefTypePath","packageDef","absolutePathForModule","resolvedFilepath","endsWith","referencePathExtractionPattern","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","relativePath","newPath","dtsRefURL","dtsReferenceResponse","dtsReferenceResponseText","getReferenceDependencies","undefined","config","noImplicitAny","strictNullChecks","strictFunctionTypes","strictPropertyInitialization","noImplicitThis","noImplicitReturns","alwaysStrict","allowUnreachableCode","allowUnusedLabels","downlevelIteration","noEmitHelpers","noLib","noStrictGenericChecks","noUnusedLocals","noUnusedParameters","esModuleInterop","preserveConstEnums","removeComments","skipLibCheck","checkJs","allowJs","experimentalDecorators","emitDecoratorMetadata","target","ScriptTarget","ES2017","jsx","monaco","languages","typescript","JsxEmit","None","language","languageType","filePath","fileExt","Uri","file","createFileUri","element","document","getElementById","elementToAppend","model","editor","createModel","monacoSettings","Object","assign","create"],"mappings":"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"}