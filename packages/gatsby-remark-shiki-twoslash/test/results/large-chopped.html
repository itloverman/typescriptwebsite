<p>
  In this case, you can use a <code>switch</code> statement to narrow down which
  type is represented at runtime:
</p>
<pre><code class="language-ts">// @errors: 2339
type NetworkLoadingState = {
  state: 'loading'
}

type NetworkFailedState = {
  state: 'failed'
  code: number
}

type NetworkSuccessState = {
  state: 'success'
  response: {
    title: string
    duration: number
    summary: string
  }
}
// ---cut---
type NetworkState = NetworkLoadingState | NetworkFailedState | NetworkSuccessState

function networkStatus(state: NetworkState): string {
  // Right now TypeScript does not know which of the three
  // potential types state could be.

  // Trying to access a property which isn't shared
  // across all types will raise an error
  state.code

  // By switching on state, TypeScript can narrow the union
  // down in code flow analysis
  switch (state.state) {
    case 'loading':
      return 'Downloading...'
    case 'failed':
      // The type must be NetworkFailedState here,
      // so accessing the `code` field is safe
      return `Error ${state.code} downloading`
    case 'success':
      return `Downloaded ${state.response.title} - ${state.response.summary}`
  }
}
</code></pre>
<h1>Intersection Types</h1>
<p>
  Intersection types are closely related to union types, but they are used very
  differently. An intersection type combines multiple types into one.
</p>

<style>
  .shiki {
    background-color: lightgrey;
    padding: 8px;
  }

  .error,
  .error-behind {
    margin-left: -20px;
    margin-right: -12px;
    margin-top: 4px;
    margin-bottom: 4px;
    padding: 6px;
    padding-left: 14px;

    white-space: pre-wrap;
    display: block;
  }

  .error {
    position: absolute;
    background-color: #ffeeee;
    border-left: 2px solid #bf1818;
    width: 100%;

    display: flex;
    align-items: center;
    color: black;
  }

  .error-behind {
    user-select: none;
    color: #ffeeee;
  }
  .query {
    color: white;
  }
</style>
